<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>다람쥐 도토리 배구</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease;
        }
        
        /* 세로 모드일 때 회전 */
        body.portrait #gameContainer {
            transform: rotate(90deg);
            transform-origin: center center;
        }
        
        #gameCanvas {
            display: block;
            border: 3px solid #8B4513;
            border-radius: 10px;
            background: linear-gradient(to bottom, #87CEEB 0%, #90EE90 70%, #228B22 100%);
            outline: none;
            max-width: 100%;
            max-height: 100%;
        }
        
        #gameInfo {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 20px;
            border-radius: 10px;
        }
        
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            pointer-events: none;
        }
        
        body.portrait #controls {
            transform: rotate(90deg);
            transform-origin: center center;
        }
        
        .left-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }
        
        .right-controls {
            pointer-events: auto;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid #333;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
        }
        
        .control-btn:active {
            transform: scale(0.9);
            background: rgba(200, 200, 200, 1);
        }
        
        #jumpBtn {
            background: rgba(255, 200, 100, 0.9);
            width: 90px;
            height: 90px;
            font-size: 18px;
        }
        
        @media (max-width: 768px) {
            #gameInfo {
                font-size: 20px;
            }
            
            .control-btn {
                width: 55px;
                height: 55px;
            }
            
            #jumpBtn {
                width: 65px;
                height: 65px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameInfo">
            <span id="leftScore">0</span> : <span id="rightScore">0</span>
        </div>
        
        <canvas id="gameCanvas" width="800" height="400" tabindex="0"></canvas>
        
        <div id="controls">
            <div class="left-controls">
                <button class="control-btn" id="upBtn">↑</button>
                <button class="control-btn" id="downBtn">↓</button>
            </div>
            <div class="right-controls">
                <button class="control-btn" id="jumpBtn">JUMP</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Orientation 감지
        function updateOrientation() {
            const isPortrait = window.innerHeight > window.innerWidth;
            document.body.className = isPortrait ? 'portrait' : 'landscape';
            resizeCanvas();
        }
        
        window.addEventListener('resize', updateOrientation);
        window.addEventListener('orientationchange', updateOrientation);
        updateOrientation();
        
        // 게임 상태
        let gameState = {
            leftScore: 0,
            rightScore: 0,
            isGameRunning: true
        };
        
        let lastTime = 0;
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        // 플레이어
        class Player {
            constructor(x, y, isLeft = true) {
                this.x = x;
                this.y = y;
                this.width = 55;
                this.height = 55;
                this.velocityX = 0;
                this.velocityY = 0;
                this.isOnGround = false;
                this.isLeft = isLeft;
                this.color = isLeft ? '#D2691E' : '#8B4513';
            }
            
            update(deltaTime) {
                this.velocityY += 1200 * deltaTime;
                this.x += this.velocityX * deltaTime;
                this.y += this.velocityY * deltaTime;
                
                const groundY = canvas.height - this.height - 20;
                if (this.y >= groundY) {
                    this.y = groundY;
                    this.velocityY = 0;
                    this.isOnGround = true;
                } else {
                    this.isOnGround = false;
                }
                
                const leftBound = this.isLeft ? 0 : canvas.width / 2 + 10;
                const rightBound = this.isLeft ? canvas.width / 2 - 10 : canvas.width - this.width;
                
                if (this.x < leftBound) this.x = leftBound;
                if (this.x > rightBound) this.x = rightBound;
                
                this.velocityX *= Math.pow(0.8, deltaTime * 60);
            }
            
            moveLeft() {
                this.velocityX = -300;
            }
            
            moveRight() {
                this.velocityX = 300;
            }
            
            jump() {
                if (this.isOnGround) {
                    this.velocityY = -600;
                    this.isOnGround = false;
                }
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                
                const tailX = this.isLeft ? this.x - 10 : this.x + this.width + 10;
                ctx.beginPath();
                ctx.ellipse(tailX, this.y + 5, 15, 25, this.isLeft ? -0.3 : 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(this.x + this.width/2 - 8, this.y + 12, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(this.x + this.width/2 + 8, this.y + 12, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x + this.width/2 - 6, this.y + this.height/2 - 3, 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(this.x + this.width/2 + 6, this.y + this.height/2 - 3, 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2 + 2, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 공
        class Ball {
            constructor() {
                this.reset();
                this.radius = 18;
                this.color = '#8B4513';
            }
            
            reset() {
                this.x = canvas.width / 2;
                this.y = 100;
                this.velocityX = Math.random() > 0.5 ? 180 : -180;
                this.velocityY = 0;
            }
            
            update(deltaTime) {
                this.velocityY += 800 * deltaTime;
                this.x += this.velocityX * deltaTime;
                this.y += this.velocityY * deltaTime;
                
                if (this.y + this.radius >= canvas.height - 20) {
                    this.y = canvas.height - 20 - this.radius;
                    this.velocityY *= -0.7;
                    this.velocityX *= Math.pow(0.9, deltaTime * 60);
                    
                    if (this.x < canvas.width / 2) {
                        gameState.rightScore++;
                        this.reset();
                    } else {
                        gameState.leftScore++;
                        this.reset();
                    }
                    updateScore();
                }
                
                if (this.x - this.radius <= 0 || this.x + this.radius >= canvas.width) {
                    this.velocityX *= -0.8;
                    this.x = this.x - this.radius <= 0 ? this.radius : canvas.width - this.radius;
                }
                
                if (this.y - this.radius <= 0) {
                    this.y = this.radius;
                    this.velocityY *= -0.8;
                }
                
                const netX = canvas.width / 2;
                const netTop = canvas.height - 120;
                if (Math.abs(this.x - netX) < this.radius + 5 && this.y + this.radius > netTop) {
                    if (this.x < netX) {
                        this.x = netX - this.radius - 5;
                    } else {
                        this.x = netX + this.radius + 5;
                    }
                    this.velocityX *= -0.8;
                }
            }
            
            checkPlayerCollision(player) {
                const dx = this.x - (player.x + player.width / 2);
                const dy = this.y - (player.y + player.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.radius + 20) {
                    const angle = Math.atan2(dy, dx);
                    const power = 480;
                    
                    this.velocityX = Math.cos(angle) * power;
                    this.velocityY = Math.sin(angle) * power - 120;
                    
                    this.x = player.x + player.width / 2 + Math.cos(angle) * (this.radius + 25);
                    this.y = player.y + player.height / 2 + Math.sin(angle) * (this.radius + 25);
                }
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.radius * 0.8, this.radius, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y - this.radius * 0.3, this.radius * 0.6, this.radius * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 1;
                for (let i = -3; i <= 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.radius * 0.5, this.y - this.radius * 0.3 + i * 3);
                    ctx.lineTo(this.x + this.radius * 0.5, this.y - this.radius * 0.3 + i * 3);
                    ctx.stroke();
                }
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x - 6, this.y - 6, this.radius / 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        const leftPlayer = new Player(100, canvas.height - 75, true);
        const rightPlayer = new Player(canvas.width - 155, canvas.height - 75, false);
        const ball = new Ball();
        
        // 컨트롤
        const keys = {};
        let upPressed = false;
        let downPressed = false;
        
        function setupButton(id, onPress, onRelease) {
            const btn = document.getElementById(id);
            btn.addEventListener('mousedown', onPress);
            btn.addEventListener('mouseup', onRelease);
            btn.addEventListener('mouseleave', onRelease);
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); onPress(); });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); onRelease(); });
        }
        
        setupButton('upBtn', () => upPressed = true, () => upPressed = false);
        setupButton('downBtn', () => downPressed = true, () => downPressed = false);
        
        document.getElementById('jumpBtn').addEventListener('click', () => leftPlayer.jump());
        document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            leftPlayer.jump();
        });
        
        // 키보드
        function handleKeyDown(e) {
            keys[e.key] = true;
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') leftPlayer.moveLeft();
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') leftPlayer.moveRight();
            if (e.key === ' ' || e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') leftPlayer.jump();
            e.preventDefault();
        }
        
        function handleKeyUp(e) {
            keys[e.key] = false;
            e.preventDefault();
        }
        
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        canvas.addEventListener('keydown', handleKeyDown);
        canvas.addEventListener('keyup', handleKeyUp);
        
        // 터치 이벤트
        let touchStartX = 0;
        let touchActive = false;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const isPortrait = window.innerHeight > window.innerWidth;
            
            if (isPortrait) {
                touchStartX = touch.clientY; // 세로 모드는 Y값 저장
            } else {
                const rect = canvas.getBoundingClientRect();
                touchStartX = touch.clientX - rect.left; // 가로 모드는 X값 저장
            }
            touchActive = true;
            // 점프 제거 - 버튼만 사용
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!touchActive) return;
            
            const touch = e.touches[0];
            const isPortrait = window.innerHeight > window.innerWidth;
            
            if (isPortrait) {
                // 세로 모드: 위아래 터치 → 좌우 이동
                const touchY = touch.clientY;
                const deltaY = touchY - touchStartX; // touchStartX를 Y값 저장용으로 재활용
                
                if (Math.abs(deltaY) > 10) {
                    if (deltaY > 0) {
                        leftPlayer.moveRight(); // 아래로 = 오른쪽
                    } else {
                        leftPlayer.moveLeft(); // 위로 = 왼쪽
                    }
                    touchStartX = touchY;
                }
            } else {
                // 가로 모드: 좌우 터치 → 좌우 이동
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const deltaX = touchX - touchStartX;
                
                if (Math.abs(deltaX) > 10) {
                    if (deltaX > 0) {
                        leftPlayer.moveRight();
                    } else {
                        leftPlayer.moveLeft();
                    }
                    touchStartX = touchX;
                }
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchActive = false;
        });
        
        function updateScore() {
            document.getElementById('leftScore').textContent = gameState.leftScore;
            document.getElementById('rightScore').textContent = gameState.rightScore;
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, canvas.height - 120);
            ctx.lineTo(canvas.width / 2, canvas.height - 20);
            ctx.stroke();
            
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(canvas.width / 2 - 3, canvas.height - 120, 6, 8);
            
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 20);
            ctx.lineTo(canvas.width, canvas.height - 20);
            ctx.stroke();
            
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, canvas.height - 20);
            ctx.lineTo(canvas.width / 2, canvas.height - 120);
            ctx.stroke();
            
            leftPlayer.draw();
            rightPlayer.draw();
            ball.draw();
        }
        
        function update(deltaTime) {
            if (!gameState.isGameRunning) return;
            
            if (keys['ArrowLeft'] || keys['a'] || keys['A'] || upPressed) leftPlayer.moveLeft();
            if (keys['ArrowRight'] || keys['d'] || keys['D'] || downPressed) leftPlayer.moveRight();
            
            // AI
            const ballDistance = Math.abs(rightPlayer.x - ball.x);
            if (ballDistance > 20) {
                if (ball.x > rightPlayer.x + 20) {
                    rightPlayer.moveRight();
                } else if (ball.x < rightPlayer.x - 20) {
                    rightPlayer.moveLeft();
                }
            }
            
            if (ball.y > rightPlayer.y && ball.velocityY > 0 && ballDistance < 80) {
                rightPlayer.jump();
            }
            
            leftPlayer.update(deltaTime);
            rightPlayer.update(deltaTime);
            ball.update(deltaTime);
            
            ball.checkPlayerCollision(leftPlayer);
            ball.checkPlayerCollision(rightPlayer);
        }
        
        function gameLoop(currentTime) {
            if (lastTime === 0) lastTime = currentTime;
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 1/60);
            lastTime = currentTime;
            
            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function resizeCanvas() {
            const isPortrait = window.innerHeight > window.innerWidth;
            
            if (isPortrait) {
                // 세로 모드: 회전된 상태 고려
                const availHeight = window.innerWidth * 0.85;
                const availWidth = window.innerHeight * 0.85;
                const scale = Math.min(availWidth / 800, availHeight / 400);
                canvas.style.width = (800 * scale) + 'px';
                canvas.style.height = (400 * scale) + 'px';
            } else {
                // 가로 모드: 화면의 85% 활용
                const availWidth = window.innerWidth * 0.95;
                const availHeight = window.innerHeight * 0.85;
                const scale = Math.min(availWidth / 800, availHeight / 400);
                canvas.style.width = (800 * scale) + 'px';
                canvas.style.height = (400 * scale) + 'px';
            }
        }
        
        updateScore();
        canvas.focus();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
